package normal49;

/**
 * 3809. 最好可到达的塔
 * 算术评级: 3
 * 同步题目状态
 * <p>
 * 中等
 * premium lock icon
 * 相关企业
 * 提示
 * 给你一个二维整数数组 towers，其中 towers[i] = [xi, yi, qi] 表示第 i 座塔的坐标 (xi, yi) 和质量因子 qi。
 * <p>
 * 另外给你一个整数数组 center = [cx, cy] 表示你的位置，以及一个整数 radius。
 * <p>
 * 如果一座塔与 center 之间的 曼哈顿距离小于或等于 radius，则称该塔是 可到达的。
 * <p>
 * 在所有可到达的塔中：
 * <p>
 * 返回质量因子 最大 的塔的坐标。
 * 如果存在并列的塔，返回坐标 字典序最小 的塔。如果没有塔是可到达的，返回 [-1, -1]。
 * 两点 (xi, yi) 和 (xj, yj) 之间的 曼哈顿距离 为 |xi - xj| + |yi - yj|。
 * 坐标 [xi, yi] 字典序小于 [xj, yj] 是指：xi < xj，或者 xi == xj 且 yi < yj。
 * <p>
 * |x| 表示 x 的 绝对值。
 * <p>
 * <p>
 * <p>
 * 示例 1：
 * <p>
 * 输入： towers = [[1,2,5], [2,1,7], [3,1,9]], center = [1,1], radius = 2
 * <p>
 * 输出： [3,1]
 * <p>
 * 解释：
 * <p>
 * 塔 [1, 2, 5]：曼哈顿距离 = |1 - 1| + |2 - 1| = 1，可到达。
 * 塔 [2, 1, 7]：曼哈顿距离 = |2 - 1| + |1 - 1| = 1，可到达。
 * 塔 [3, 1, 9]：曼哈顿距离 = |3 - 1| + |1 - 1| = 2，可到达。
 * 所有塔都是可到达的。最大质量因子为 9，对应塔 [3, 1]。
 * <p>
 * 示例 2：
 * <p>
 * 输入： towers = [[1,3,4], [2,2,4], [4,4,7]], center = [0,0], radius = 5
 * <p>
 * 输出： [1,3]
 * <p>
 * 解释：
 * <p>
 * 塔 [1, 3, 4]：曼哈顿距离 = |1 - 0| + |3 - 0| = 4，可到达。
 * 塔 [2, 2, 4]：曼哈顿距离 = |2 - 0| + |2 - 0| = 4，可到达。
 * 塔 [4, 4, 7]：曼哈顿距离 = |4 - 0| + |4 - 0| = 8，不可到达。
 * 在可到达的塔中，最大质量因子为 4。[1, 3] 和 [2, 2] 的质量因子相同，因此返回字典序较小的坐标 [1, 3]。
 * <p>
 * 示例 3：
 * <p>
 * 输入： towers = [[5,6,8], [0,3,5]], center = [1,2], radius = 1
 * <p>
 * 输出： [-1,-1]
 * <p>
 * 解释：
 * <p>
 * 塔 [5, 6, 8]：曼哈顿距离 = |5 - 1| + |6 - 2| = 8，不可到达。
 * 塔 [0, 3, 5]：曼哈顿距离 = |0 - 1| + |3 - 2| = 2，不可到达。
 * 在给定半径内没有可到达的塔，故返回 [-1, -1]。
 * <p>
 * <p>
 * <p>
 * 提示：
 * <p>
 * 1 <= towers.length <= 105
 * towers[i] = [xi, yi, qi]
 * center = [cx, cy]
 * 0 <= xi, yi, qi, cx, cy <= 105
 * 0 <= radius <= 105
 */
public class Code24 {

    public int[] bestTower(int[][] towers, int[] center, int radius) {
        //初始化结果
        int[] result = new int[]{-1, -1};
        //开始坐标
        int x = center[0];
        int y = center[1];
        //重量
        int weight = -1;
        //循环
        for (int[] tower : towers) {
            //计算距离
            int walk = Math.abs(tower[0] - x) + Math.abs(tower[1] - y);
            //如果距离太远
            if (walk > radius) {
                //本轮过
                continue;
            }
            //如果距离小于半径
            if (tower[2] > weight) {
                //更新重量
                weight = tower[2];
                //更新结果
                result = new int[]{tower[0], tower[1]};
            } else if (tower[2] == weight) {
                //如果字典序更小
                if (tower[0] < result[0] || (tower[0] == result[0] && tower[1] < result[1])) {
                    //更新结果
                    result = new int[]{tower[0], tower[1]};
                }
            }
        }
        //返回
        return result;
    }

    public static void main(String[] args) {
        //int[] ints = new Code24().bestTower(new int[][]{{1, 2, 5}, {2, 1, 7}, {3, 1, 9}}, new int[]{1, 1}, 2);
        int[] ints = new Code24().bestTower(new int[][]{{1, 3, 4}, {2, 2, 4}, {4, 4, 7}}, new int[]{0, 0}, 5);


        System.out.println();
    }

}
