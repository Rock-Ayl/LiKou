package easy15;

/**
 * @Author ayl
 * @Date 2021-11-26
 * 999. 可以被一步捕获的棋子数
 * 在一个 8 x 8 的棋盘上，有一个白色的车（Rook），用字符 'R' 表示。棋盘上还可能存在空方块，白色的象（Bishop）以及黑色的卒（pawn），分别用字符 '.'，'B' 和 'p' 表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。
 * <p>
 * 车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，直到满足下列四个条件之一：
 * <p>
 * 棋手选择主动停下来。
 * 棋子因到达棋盘的边缘而停下。
 * 棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。
 * 车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。
 * 你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。
 * <p>
 * <p>
 * <p>
 * 示例 1：
 * <p>
 * <p>
 * <p>
 * 输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
 * 输出：3
 * 解释：
 * 在本例中，车能够捕获所有的卒。
 * 示例 2：
 * <p>
 * <p>
 * <p>
 * 输入：[[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
 * 输出：0
 * 解释：
 * 象阻止了车捕获任何卒。
 * 示例 3：
 * <p>
 * <p>
 * <p>
 * 输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]]
 * 输出：3
 * 解释：
 * 车可以捕获位置 b5，d6 和 f5 的卒。
 * <p>
 * <p>
 * 提示：
 * <p>
 * board.length == board[i].length == 8
 * board[i][j] 可以是 'R'，'.'，'B' 或 'p'
 * 只有一个格子上存在 board[i][j] == 'R'
 */
public class Code11 {

    //次数
    int size = 0;
    char[][] board;

    public void top(int x, int y) {
        //如果没到头
        if (--y >= 0) {
            //如果是大象
            if (board[x][y] == 'B') {
                //过
                return;
            }
            //如果找到
            if (board[x][y] == 'p') {
                //+1
                size++;
                //过
                return;
            }
            //下一个
            top(x, y);
        }
    }

    public void under(int x, int y) {
        //如果没到头
        if (++y < this.board.length) {
            //如果是大象
            if (board[x][y] == 'B') {
                //过
                return;
            }
            //如果找到
            if (board[x][y] == 'p') {
                //+1
                size++;
                //过
                return;
            }
            //下一个
            under(x, y);
        }
    }

    public void left(int x, int y) {
        //如果没到头
        if (--x >= 0) {
            //如果是大象
            if (board[x][y] == 'B') {
                //过
                return;
            }
            //如果找到
            if (board[x][y] == 'p') {
                //+1
                size++;
                //过
                return;
            }
            //下一个
            left(x, y);
        }
    }

    public void right(int x, int y) {
        //如果没到头
        if (++x < this.board[0].length) {
            //如果是大象
            if (board[x][y] == 'B') {
                //过
                return;
            }
            //如果找到
            if (board[x][y] == 'p') {
                //+1
                size++;
                //过
                return;
            }
            //下一个
            right(x, y);
        }
    }

    public int numRookCaptures(char[][] board) {
        //全局
        this.board = board;
        //循环1
        for (int i = 0; i < board.length; i++) {
            //循环2
            for (int j = 0; j < board[0].length; j++) {
                //如果找到了车
                if (board[i][j] == 'R') {
                    //上下左右
                    top(i, j);
                    under(i, j);
                    left(i, j);
                    right(i, j);
                    //直接返回
                    return size;
                }
            }
        }
        //返回
        return size;
    }

}
